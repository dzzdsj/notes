jvm知识点

# JVM的内存结构





# 标记待回收的对象

## 引用计数算法

给对象加一个引用计数器， 每当有 一个地方引用，计数器值就加1, 当引用失效时， 计数器值就减1, 任何时刻计数器为0的对象就是不可能再被使用的

1. 无法解决循环引用问题

## 可达性分析算法

通过一系列的称为“ GC Root"的对象作为起始点， 从这些节点开始向下 搜索， 搜索所走过的路径称为引用链(ReferenceCham)， 当一个对象到GC Roots没有任何引用链， 则证明此对象是不可用的

可以作为GC-Root的对象：

1. 虚拟机栈（本地变量表）引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常类引用的对象
4. 本地方法栈中JNI（Native方法）引用的对象

### 引用的类型

1. 强引用：永远不会回收强引用的对象。（Object a = new Object（））
2. 软引用：即将发生内存溢出之前，会对其进行二次回收。若第二次回收后还内存不足，将抛出内存溢出异常
3. 弱引用：只会生存到下次GC之前，GC时无论内存够不够都会被回收
4. 虚引用：对生存周期无任何影响。唯一用处是对象被回收时收到一个系统通知

# GC算法

## 标记-清除算法

标记出所有需要回收的对彖， 在标记完成后统一回收所有被标记的对象。

1. 标记和清除效率不高
2. 产生不连续的空间碎片

## 复制算法

内存等分为两块， 每次只使用其中的一块．当这一块的内存用完了， 就将还存活着的对象复制到另外一块上面． 然后再把已使用过的内存空间一次清理掉。

1. 效率提高了，但内存浪费，只能使用一半
2. 对象存活多时，效率降低

## 标记-整理算法

标记清除算法的改进版，存活的对象移动到一端，清理掉端边界以外的内存。

## 分代收集算法

根据对象存活周期的不同将内存划分为几块， 根据各个年代的恃点采用最适当的收集算法

1. 新生代：复制算法 （每次GC大量对象死去）
2. 老年代：标记-清除或标记-整理 （少量对象死去）



