

## B*树索引访问路径



| Access Path（访问路径） | 使用场景                                                     | 工作原理                                                     | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Index Unique Scans      | 仅当查询谓词指定了一个唯一索引的所有列且是一个等值操作       | 在索引中找到第一个匹配的key后立刻停止搜索，之后使用rowid取数据 | 1.最多返回1行记录。2.仅有唯一约束或主键约束并不足以提供索引唯一扫描（可能在建立约束之前，列上已经存在了非唯一的索引） |
| Index Range Scans       | 1.查询包含前导列。2.索引键不是唯一的。3.查询谓词包含=，>,<或它们的组合形式 | 算法大致为：1.扫描root block。2.扫描branch block。3.交替执行以下步骤，直到获取所有数据：扫描leaf block获取rowid，根据rowid访问表数据。（找到第一个leaf block后，在leaf block双向链表间水平移动查找） | 1.是一种顺序扫描，有时可以避免额外的排序（针对索引列排序时）。2.优化器一般针对高选择性的列考虑索引范围扫描。 |
| Index Full Scans        | 1.查询谓词引用了索引中的列。2.虽然没有查询谓词，但满足索引列包含所有的查询列且至少有一个索引列为非空。3.查询对非空索引列进行order by | 查询root block、branch block找到最左或最右（倒序时）的leaf block，按顺序扫描leaf block，一次扫描一个block。（single-block I/O） | 1.按顺序扫描整个索引。2.可以消除排序                         |
| Index Fast Full Scans   | 索引列包含了所有待查询的列                                   | 使用multiblock I/O直接扫描leaf block。                       | 1.无序地扫描索引，且不再查表。2.无法消除排序                 |
| Index Skip Scans        | 1.查询时未包含索引的前导列。2.前导列的选择性差而非前导列的选择性很好 | 逻辑上地拆分组合索引为更小的子索引。前导列的唯一值越少（选择性越差）则子索引的数量越少，从而扫描越高效。独立地扫描各个子索引，跳过不满足条件的索引块（针对查询条件（非前导列）） | 一般比全索引扫描及全表扫描快。                               |
| Index Join Scans        | 1.使用hash连接多个索引可以返回待查询的所有列，而不需要再查表。2.当查表数据的花销大于索引连接查询时（一般来说，选择一个选择性最好的索引再访问表会是更高效的查询方式） | 大致过程如下：1.扫描第一个索引获取rowid。2.扫描第二个索引获取rowid。3.通过rowid执行hash连接来获取行。 | 使用hash连接多个索引以返回待查询的列（不再查表）             |



## B*树索引逻辑结构

