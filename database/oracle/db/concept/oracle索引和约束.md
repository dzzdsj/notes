
## 索引
### 索引的作用
索引有两个作用：一是强制实施主键约束和唯一约束；二是提高性能。
1. 索引是约束机制的一部分
   主键约束、唯一约束（与主键约束的区别在于值可以为null,可以多条null）都需要索引。

   引申：
   - 建立主键约束、唯一约束时，如果列上不存在索引，oracle会自动创建（二者都需要校验唯一性，如无索引，那只能通过全表扫描了）
   - 唯一约束与主键约束的区别在于值可以为null
   - 为了提高性能，子表的外键约列上应该创建索引（如果能用索引确认子表中是否存在引用被删除行的行，那么父表上的delete操作速度将大大提升）
      
2. 提高性能
提升带where子句的sql操作、排序、表联接时的性能
    引申：
    - 提升使用where子句的select，和任何update、delete、merge操作效率，但对于insert语句会降低处理速度。
    - 索引提升select性能，但降低DML操作性能（需要额外维护索引）
    - 表较大或需要检索的比例低于特定的值（一般为2%-4%），索引查找较快（反之，表较小或检索表中大部分的行时，全表扫描较快）
    - 排序的场景，如order by，group by，union等
    - 表联接时，即使有索引，oracle仍会根据表的大小和可用的内存资源做出选择：将表扫描到内存中并在那里将它们联接在一起可能比使用索引更快。如果没有索引，oracle将在可用的联接技术方面受到严重的限制。
    - 表联接的技术：
    循环嵌套联接（nested loop join）：使用另一个表上的索引遍历一个表来定位匹配行，通常是一个磁盘密集型操作。
    哈希联接（hash join）：将整个表读入内存，将其转换为哈希表，然后使用哈希算法定位匹配的行，这是一个内存和cpu更为密集的操作。
    排序合并联接（sort merge join）：在联接列上排序表，然后将它们合并在一起，通常是磁盘、内存和cpu资源之间的折中。

### 索引的类型
#### B*树索引（balanced平衡树）
 - 树的深度：主要取决于表中的行数以及索引键值的长度。（如果深度大于三级或四级，则说明索引键十分长，或表包含数十亿行。如果情况并非如此，则需要重建索引）
- rowid：行的指针。oracle专用的虚拟列。rowid加密项给出了行的物理地址，oracle根据此地址计算行在操作系统文件的哪个文件和哪个位置。rowid在全局上是唯一的。
- null值不会参与到B树索引，以此始终导致全表扫描。
- 如果列的选择性不充分（列包含的唯一值很少），那么在列上创建B树索引就没什么价值

##### 适合使用B树索引的情况
- 列的基数（不同值的个数）很大
- 表的行数多
- 列用在where子句或join条件中
  
#### 位图索引
- 位图索引将与每个键值关联的rowid存储为位图。
- 位图的合并速度极快，可使用AND、OR、NOT操作符的任意组合，基于很多列上的很多条件，实现复杂的布尔操作。
- 位图索引包含NULL，就位图索引而言，NULL只不过是另一个具有自己位图的不同值而已。
##### 适合使用位图索引的情况
- 列的基数（不同值的个数）小
- 表中的行数多
- 列用于布尔代数计算
### 索引类型选项
- 唯一或非唯一(Unique or non-unique)
- 反向键(Reverse key)
- 压缩(Compressed)
- 复合(Composite)
- 基于函数(Function based)
- 升序或降序(Ascending or descending)

以上选项都可用于B树索引，但位图索引只适用后三个选项。
索引的唯一特性独立于唯一约束。（唯一约束或主键约束可以使用非唯一索引）
反向键：将列进行反转（John->nhoJ）,用于避免争用（多用户并发插入连续增长的编号等）
压缩索引仅将重复键值存储一次
复合索引：索引含两个或多个列。对混合的数据类型没有限制。搜索时可以不必包含所有列。但如果不包含最左边的列，oracle会使用跳过-扫描（skip-scanning）方法，效率低很多。
函数索引：查询时必须使用与定义索引时相同的函数，否则不能使用索引

## 约束
- unique
- not null
- primary key
- foreign key
- check 









