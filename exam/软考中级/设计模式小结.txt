23种设计模式，主要分三类

--------------------------------------------------------------------------------------------------------------------------
      创建型：对象的创建            结构型：处理类或对象的组合                      行为型：类或对象怎样交互和怎样分配职责
                                                                                                                          
                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------
类    使用继承改变被实例化的类      使用继承机制来组合接口或实现                     使用继承机制(对象复合而非继承)在类间分派行为                                                                                               
      Factory Method(工厂方法)       Adaptor(适配器-类)                           Interpreter(解释器)
                                                                                 Template Method()                                     
                                                                                                                          
                                                                                                                          
                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------
对象  将实例化委托给另一个对象      如何对一些对象进行组合，从而实现新功能的一些方法                                                                                                                
      Abstract Factory(抽象工厂)    Adaptor(适配器-对象)                          Chain of Responsibility(责任链)
      Builder(生成器)               Bridge(桥接)                                 Command(命令)
      Prototype(原型)               Composite(组合)                              Iterator(迭代器)
      Singleton(单例)               Decorator(装饰)                              Mediator(中介者)
                                    Facade(外观)                                 Memento(备忘录)                                           
                                    Flyweight(享元)                              Observer(观察者)
                                    Proxy(代理)                                  State(状态)                                            
                                                                                 Strategy(策略)                                       
                                                                                 Visitor(访问者)                                       
--------------------------------------------------------------------------------------------------------------------------
Factory Method(工厂方法):定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到它的子类。      
Abstract Factory(抽象工厂):提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类。
      何时使用：一个系统需要将产品的创建、组合和表示独立出来的时候
               一个系统要由多个产品系列中的一个来配置时
               想要强调一系列产品对象的设计以便进行联合使用时(遵循统一的设计等出发点)
               当你提供一个产品类库，但只想暴露它的接口而不是具体实现时
      优点：封装性，将对象使用者(client)和具体的创建对象的类分离，而只暴露接口，客户通过接口操纵实例。产品类名也在具体工厂的实现中被分离。
            变更产品的系列很容易。一个具体的工厂类只在做初始化时出现一次，仅需改变这个具体工厂类即可实现改变产品类型。
            利于产品的一致性。一系列的产品被组织在一起，实现统一的对外接口。
      缺点：扩展新产品困难。抽象工厂接口定义了可以被创建的产品的集合。增加新产品需要扩展接口，它所有的子类都需要进行变更。
      思考：用单例实现工厂。一般每种产品只需要一个ConcreteFactory，最好将其实现为单例。
           用原型模式减少具体工厂类数量。如果有多个产品，具体工厂类也可以考虑通过原型模式来实现，这使得不是每个新的产品系列都需要一个新具体工厂类
           抽象工厂的扩展性。可以考虑增加一个表示类型的参数来指示要创建工厂的类型，客户用基类接口进行统一操作，必要时做向下转型(处理不当可能会有异常)。
Builder(生成器):将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以构建不同的表示。
      
Prototype(原型):用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
Singleton(单例):保证一个类仅有一个实例，并提供一个访问它的全局访问点。
Adaptor(适配器):将一个类的一个接口转换成另一个接口，使得原本不兼容的类可以一起工作。
Bridge(桥接):将抽象部分和实现部分分离，使它们可以独立的变化。
Composite(组合):将对象表示成树型结构以表示整体-部分的层次结构，使得对单个对象和组合对象的使用具有一致性。
Decorator(装饰):动态地给一个对象添加一些额外的职责，这比生成子类扩展的方式更灵活。
Facade(外观):为子系统的一组接口提供一个一致的界面，通过定义一个高层接口，使得子系统更加容易使用。
Flyweight(享元):运用共享技术有效地支持大量细粒度的对象。
Proxy(代理):为其他对象提供一种代理以控制对这个对象的访问。
Interpreter(解释器):给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释使用该表示来解释语言中的句子。
Template Method():定义算法骨架，将其中一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
Chain of Responsibility(责任链):把处理请求的对象连成一条链，沿着这条链传递请求，直到有一个对象处理它为止。
Command(命令):将一个请求封装为一个对象，使得可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，支持可撤销的操作。
Iterator(迭代器):提供一种方法顺序访问一个聚合对象中的各个元素，且不需要暴露该对象的内部表示。
Mediator(中介者):用一个中介对象来封装一系列的对象交互。使对象间不需要显式地互相引用，松耦合，且可以独立地改变它们之间的交互。
Memento(备忘录):在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态，这样可以支持将对象恢复到原先保存的状态。
Observer(观察者):定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新。
State(状态):允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎改变了它的类。
Strategy(策略):定义一系列的算法，把它们封装起来，且使它们可以相互替换。使得算法可以独立于使用它们的客户而变化。
Visitor(访问者):表示一个作用于某对象结构中的各元素的操作。它允许在不改变各元素的类的前提下定义作用于这些元素的新操作。












